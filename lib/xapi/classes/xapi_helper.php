<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * xAPI LRS Restful responses support.
 *
 * @package    core_xapi
 * @since      Moodle 3.9
 * @copyright  2020 Ferran Recio
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace core_xapi;
defined('MOODLE_INTERNAL') || die();

require_once($CFG->libdir . '/externallib.php');

use moodle_exception;
use moodle_url;
use stdClass;

/**
 * Class to translate Moodle objects to xAPI elements.
 *
 * @copyright  2020 Ferran Recio
 * @since      Moodle 3.9
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class xapi_helper {

    /**
     * Returns the xAPI handler of a specific component.
     *
     * @param string $component the component name in frankenstyle.
     * @return xapi_handler_base|null a xapi_handler_base object or null if none found.
     */
    public static function get_xapi_handler(string $component): ?xapi_handler_base {
        // Get component xAPI statement handler class.
        $handlerclassname = "\\$component\\xapi_handler";
        if (!class_exists($handlerclassname)) {
            return null;
        }
        return new $handlerclassname($component);
    }

    /**
     * Return a valid xAPI agent from a user record.
     *
     * @param stdClass $user a User record
     * @return stdClass to use as a xAPI actor
     */
    public static function xapi_agent(stdClass $user): stdClass {
        global $CFG;
        $result = new stdClass();
        $result->objectType = "Agent";
        $result->account = (object)[
            'homePage' => $CFG->wwwroot,
            'name' => $user->id
        ];
        return $result;
    }

    /**
     * Return a valid xAPI Group from a group record.
     *
     * @param stdClass $group Moodle group record
     * @return stdClass to use as a xAPI actor
     */
    public static function xapi_group(stdClass $group): stdClass {
        global $CFG;
        $result = new stdClass();
        $result->objectType = "Group";
        $result->name = $group->name;
        $result->account = (object)[
            'homePage' => $CFG->wwwroot,
            'name' => $group->id
        ];
        return $result;
    }

    /**
     * Return a valid xAPI verb from a component textual verb.
     *
     * @param string $verb
     * @return stdClass to use as a xAPI verb
     */
    public static function xapi_verb(string $verb): stdClass {
        $result = new stdClass();
        $result->id = self::generate_iri($verb, 'verb');
        return $result;
    }

    /**
     * Return a valid xAPI object.
     *
     * @param string $token Token generated by plugin
     * @return stdClass to use as a xAPI object
     */
    public static function xapi_object(string $token): stdClass {
        $result = new stdClass();
        $result->objectType = "Activity";
        $result->id = self::generate_iri($token, 'object');
        return $result;
    }

    /**
     * Generate a valid IRI element from a $value and an optional $type.
     *
     * Verbs and Objects in xAPI are in IRI format. This function could get
     * a valid IRI value (and will return without modifiyng it) or a simple
     * string and a type and generate a fake IRI valir for any xAPI statement.
     *
     * @param string $value a valid IRI value or any string
     * @param string|null $type if none passed $type will be 'element'
     * @return string a valid IRI value
     */
    public static function generate_iri(string $value, string $type = null): string {
        global $CFG;
        if (empty($type)) {
            $type = 'element';
        }
        if (substr($value, 0, 4) === "http") {
            return $value;
        }
        return "$CFG->wwwroot/xapi/$type/$value";
    }

    /**
     * Try to extract the original value from an IRI.
     *
     * If a real IRI value is passed, it will return it without any change. If a
     * fake IRI is passed (generated by \core_xapi\xapi_helper::generate_iri)
     * it will try to extract the original value.
     *
     * @param string $value the current IRI value.
     * @param string|null $type if $value is a fake IRI, the $type must be provided.
     * @return string the original value used in \core_xapi\xapi_helper::generate_iri.
     */
    public static function extract_iri_value(string $value, string $type = null): string {
        if (empty($type)) {
            $type = 'element';
        }
        $fakeiri = (new moodle_url("/xapi/$type/"))->out(false);
        if (strpos($value, $fakeiri) === 0) {
            return substr($value, strlen($fakeiri));
        }
        return $value;
    }

    /**
     * Check if a $value could be a valid IRI or not.
     *
     * @param string $value the current IRI value.
     * @return bool if the $value could be an IRI.
     */
    public static function check_iri_value(string $value): bool {
        try {
            new moodle_url($value);
        } catch (moodle_exception $e) {
            return false;
        }

        return true;
    }
}
